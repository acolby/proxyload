# Proxy Utility

A utility function that creates a nested proxy structure for dynamically loading and executing code based on type and name hierarchies, using the manifest and loader mappings generated by the build utility.

## Overview

The `proxy` function creates a two-level proxy system where:

- First level: **Type** (e.g., "Component", "Service", "Util")
- Second level: **Name** (e.g., "Button", "AuthService", "formatDate")

The function automatically retrieves loader mappings and manifest data from the release object, simplifying the configuration and enabling runtime code loading.

## Usage

```typescript
import proxy from "@acolby/proxyload/src/proxy";

const proxied = proxy({
  host: "https://example.com",
  globals: {
    React: require("react"),
    JSX: require("react/jsx-runtime"),
  },
  ref: "_PX_", // adds the proxied object to global this so that things items can reference other items
  // this is usefule if you "build" script includles "@proxed": '_PX_'
});

// Usage examples:

proxied.Component.Button({ variation: "primary" });
const result = await proxied.Util.formatDate({ variation: "short" });
```

## Parameters

- `host`: Base URL for loading resources (required)
- `globals`: Global variables to make available to loaded modules (required)
- `ref`: Optional release key (defaults to the current global release)

## How It Works

1. **Global Injection:** All keys in the `globals` object are injected into `globalThis` before any modules are loaded. This enables runtime dependency injection for things like React, JSX, etc.
2. **Proxy Structure:** Returns a nested proxy: `Proxied[Type][Name]`. Each property access returns a function that invokes the appropriate loader for that type and name.
3. **Loader Resolution:** The loader for each type is resolved from `globalThis._PL_.releases[releaseKey].loaders[type]` and must be present in `globalThis._PL_.items`.
4. **Versioning:** The version for each module is resolved from the manifest: `globalThis._PL_.releases[releaseKey].manifest["Type/Name/Variation"]`. The default variation is `default`.
5. **Memoization:** Each proxy function is memoized by `[releaseKey]/[Type]/[Name]` for efficiency.
6. **Release Key:** By default, the current release key is used (`globalThis._PL_.current`). You can override this with the `ref` option.

## Required Global Structure

The proxy utility expects the following global structure (created by the build utility):

- `globalThis._PL_.items` - Contains all loaded modules
- `globalThis._PL_.releases[key].loaders` - Loader mappings for each type
- `globalThis._PL_.releases[key].manifest` - Version mappings for modules
- `globalThis._PL_.releases[key].globals` - Global variables for the release
- `globalThis._PL_.current` - The currently active release key

**Important:**

- On the **client**, you must load the release script before using the proxy:
  ```html
  <script src="https://example.com/releases/latest/client.js"></script>
  <!-- Then your app bundle -->
  ```
- On the **server**, load the server release script before using the proxy:
  ```js
  require("/path/to/dist/releases/latest/server.js");
  // Then require your app code
  ```

If the release is not loaded, the utility will throw an error with instructions.

## Error Handling

If the required release is not loaded, an error is thrown with instructions for loading the correct script. If a loader is missing, an error is logged to the console.

## Advanced Usage

- **Custom Namespace:** The proxy always uses the `_PL_` namespace for global release data.
- **Custom Release Key:** Use the `ref` option to target a specific release (e.g., for versioned or staged deployments).
- **Async Support:** The proxy functions can be used with both sync and async loaders, depending on your loader implementation.
- **Globals Injection:** All globals are injected into `globalThis` at load time, so you can provide any runtime dependency (e.g., React, JSX, custom utilities).

## Troubleshooting

- **Release Not Loaded:** Ensure the correct `client.js` or `server.js` script is loaded before your app code.
- **Loader Not Found:** Check that your build process generated the correct loader and that it is present in `globalThis._PL_.items`.
- **Manifest Entry Missing:** Make sure your build process included the module and variation you are trying to load.

## Example: Full Integration

```typescript
import proxy from "@acolby/proxyload/src/proxy";
import React from "react";
import JSX from "react/jsx-runtime";

// Ensure the release script is loaded first!
const Proxied = proxy({
  host: "https://example.com",
  globals: { React, JSX },
  // ref: "v1.0.0", // Optional: use a specific release
});

// Usage
<Proxied.Component.Button
  text="Click me"
  onClick={() => alert("clicked!")}
/>;
```
