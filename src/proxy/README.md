# Proxy Utility

A utility function that creates a nested proxy structure for dynamically loading and executing code based on type and name hierarchies, using the manifest and loader mappings generated by the build utility with dependency injection support.

## Overview

The `proxy` function creates a two-level proxy system where:

- First level: **Type** (e.g., "Component", "Service", "Util")
- Second level: **Name** (e.g., "Button", "AuthService", "formatDate")

The function automatically retrieves loader mappings and manifest data from the release object, simplifying the configuration and enabling runtime code loading with dependency injection.

## Usage

```typescript
import proxy from "@acolby/proxyload/src/proxy";

const proxied = proxy({
  host: "https://example.com",
  dependencies: {
    react: require("react"),
    "react/jsx-runtime": require("react/jsx-runtime"),
  },
  proxyImport: "@proxied", // Optional: custom import name for self-referencing (default: "@proxied")
});

// Usage examples:

proxied.Component.Button({ variation: "primary" });
const result = await proxied.Util.formatDate({ variation: "short" });
```

## Parameters

- `host`: Base URL for loading resources (required)
- `dependencies`: Dependencies to inject into loaded modules (required)
- `proxyImport`: Optional import name for self-referencing (default: "@proxied")

## How It Works

1. **Dependency Injection:** All keys in the `dependencies` object are passed to loaded modules through the `_DI_PROXY_` parameter. This enables runtime dependency injection for things like React, JSX, etc.
2. **Proxy Structure:** Returns a nested proxy: `Proxied[Type][Name]`. Each property access returns a function that invokes the appropriate loader for that type and name.
3. **Loader Resolution:** The loader for each type is resolved from `globalThis._PL_.releases[releaseKey].loaders[type]` and must be present in `globalThis._PL_.items`.
4. **Versioning:** The version for each module is resolved from the manifest: `globalThis._PL_.releases[releaseKey].manifest["Type/Name/Variation"]`. The default variation is `default`.
5. **Memoization:** Each proxy function is memoized by `[releaseKey]/[Type]/[Name]` for efficiency.
6. **Release Key:** By default, the current release key is used (`globalThis._PL_.current`). You can override this with the `ref` option.

## Dependency Injection

The proxy utility uses dependency injection to pass dependencies to modules at runtime. This approach provides several benefits:

- **Isolation**: Modules don't depend on global state
- **Testability**: Dependencies can be easily mocked by passing different dependency objects
- **Flexibility**: Different dependency versions can be injected at runtime
- **Type Safety**: The dependency object can be typed for better IDE support

**How DI Works:**

1. **Module Wrapping**: Each built module is wrapped in a function that receives `_DI_PROXY_` as a parameter
2. **Import Rewriting**: ES6 imports are transformed to read from the DI proxy instead of global namespace
3. **Runtime Injection**: Dependencies are injected at runtime through the proxy system

**Example of DI Transformation:**

```tsx
// Original code
import React from "react";
import { jsx, jsxs } from "react/jsx-runtime";

const Button = (props) => {
  return <button onClick={props.onClick}>{props.label}</button>;
};

export default Button;
```

```js
// Built output with DI
globalThis._PL_.items["Component/Button/default/hash"] = (_DI_PROXY_) => {
  var React = _DI_PROXY_["react"];
  var { jsx, jsxs } = _DI_PROXY_["react/jsx-runtime"];

  const Button = (props) => {
    return jsx("button", { onClick: props.onClick, children: props.label });
  };

  return Button;
};
```

## Required Global Structure

The proxy utility expects the following global structure (created by the build utility):

- `globalThis._PL_.items` - Contains all loaded modules (wrapped in DI functions)
- `globalThis._PL_.releases[key].loaders` - Loader mappings for each type
- `globalThis._PL_.releases[key].hashes` - Hash mappings for modules
- `globalThis._PL_.releases[key].dependencies` - Dependency mappings for the release
- `globalThis._PL_.current` - The currently active release key

**Important:**

- On the **client**, you must load the release script before using the proxy:
  ```html
  <script src="https://example.com/releases/latest/client.js"></script>
  <!-- Then your app bundle -->
  ```
- On the **server**, load the server release script before using the proxy:
  ```js
  require("/path/to/dist/releases/latest/server.js");
  // Then require your app code
  ```

If the release is not loaded, the utility will throw an error with instructions.

## Error Handling

If the required release is not loaded, an error is thrown with instructions for loading the correct script. If a loader is missing, an error is logged to the console.

## Advanced Usage

- **Custom Namespace:** The proxy always uses the `_PL_` namespace for global release data.
- **Custom Release Key:** Use the `ref` option to target a specific release (e.g., for versioned or staged deployments).
- **Async Support:** The proxy functions can be used with both sync and async loaders, depending on your loader implementation.
- **Dependency Injection:** All dependencies are passed through the `_DI_PROXY_` parameter at load time, so you can provide any runtime dependency (e.g., React, JSX, custom utilities).

## Troubleshooting

- **Release Not Loaded:** Ensure the correct `client.js` or `server.js` script is loaded before your app code.
- **Loader Not Found:** Check that your build process generated the correct loader and that it is present in `globalThis._PL_.items`.
- **Manifest Entry Missing:** Make sure your build process included the module and variation you are trying to load.
- **Dependency Not Found:** Ensure that all required dependencies are included in the `dependencies` object passed to the proxy function.

## Example: Full Integration

```typescript
import proxy from "@acolby/proxyload/src/proxy";
import React from "react";
import JSX from "react/jsx-runtime";

// Ensure the release script is loaded first!
const Proxied = proxy({
  host: "https://example.com",
  dependencies: {
    react: React,
    "react/jsx-runtime": JSX,
  },
  // proxyImport: "@proxied", // Optional: custom import name
});

// Usage
<Proxied.Component.Button
  text="Click me"
  onClick={() => alert("clicked!")}
/>;
```

## Self-Referencing

The proxy utility supports self-referencing, allowing modules to import other modules from the same proxied structure:

```typescript
// In a module, you can import other proxied modules
import { Component } from "@proxied";

const Layout = (props) => {
  return (
    <div>
      <Component.Header />
      {props.children}
      <Component.Footer />
    </div>
  );
};

export default Layout;
```

The `@proxied` import is automatically resolved to the proxy object, enabling modular composition within the proxied structure.
