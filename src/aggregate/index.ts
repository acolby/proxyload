import fs from "node:fs";
import path from "node:path";

export default async function aggregate(params: {
  exclude: string[];
  dir: string;
}) {
  const { dir } = params;
  const types = fs
    .readdirSync(dir)
    .filter((name) => !name.includes("."))
    .filter((name) => !params.exclude.includes(name));

  for (const type of types) {
    const names = fs
      .readdirSync(path.resolve(dir, type))
      .filter((name) => !name.includes("."));

    const items = names.map((name) => {
      const variations = fs
        .readdirSync(path.resolve(dir, type, name))
        .filter((name) => !name.includes("."));
      return { name, variations };
    });

    for (const item of items) {
      fs.writeFileSync(
        path.resolve(`${dir}/${type}/${item.name}/index.ts`),
        _createVariationsFile({
          name: item.name,
          variations: item.variations,
        })
      );

      fs.writeFileSync(
        path.resolve(`${dir}/${type}/${item.name}/types.ts`),
        _createItemsTypeFile({
          name: item.name,
          variations: item.variations,
        })
      );
    }

    // Generate individual index files for each item with its variations
    for (const item of items) {
      fs.writeFileSync(
        path.resolve(`${dir}/${type}/${item.name}/index.ts`),
        _createVariationsFile({
          name: item.name,
          variations: item.variations,
        })
      );
    }
  }
}

function _createVariationsFile(params: { name: string; variations: string[] }) {
  const { name, variations } = params;

  const imports: string[] = [];
  const variationEntries: string[] = [];

  // Generate import statements for each variation
  for (const variation of variations) {
    imports.push(`import ${name}_${variation} from "./${variation}";`);
    variationEntries.push(`    ${variation}: ${name}_${variation},`);
  }

  const variationsType = variations.map((v) => `"${v}"`).join(" | ");

  const fileContent = `
// This file was generated by proxyload
import type { Component_${name} } from "./types";

${imports.join("\n")}

type Variations = ${variationsType};

export const ${name}: Component_${name} = (props) => {
  const { variation = "${variations[0]}" } = props;
  const variationMap = {
${variationEntries.join("\n")}
  };
  return variationMap[variation || "${
    variations[0]
  }"]?.(props) ?? variationMap["${variations[0]}"](props);
};
`;

  return fileContent;
}

function _createItemsTypeFile(params: { name: string; variations: string[] }) {
  const { name, variations } = params;
  return `
  import type { Params, Returns } from "./interface";

  type Variations = ${variations.map((v) => `"${v}"`).join(" | ")};

  export type Component_${name} = (
    props: Params & { variation?: Variations; version?: string }
  ) => Returns;
  `;
}

function _aggregateItems(params: {
  type: string;
  items: { name: string; variations: string[] }[];
}) {
  const { type, items } = params;
  const imports: string[] = [];
  const variationTypes: string[] = [];
  const typeEntries: string[] = [];
  const idEntries: string[] = [];
  const entries: string[] = [];

  // import the interface types
  for (const item of items) {
    // Add import statements
    imports.push(
      `import type { Params as Params_${item.name}, Returns as Returns_${item.name} } from "./${item.name}/interface";`
    );

    // Add import statements
    variationTypes.push(
      `type ${item.name}_variations = ${item.variations
        .map((item) => `"${item}"`)
        .join(" | ")};`
    );

    typeEntries.push(
      `  ${item.name}: (props: Params_${item.name} & { variation?: ${item.name}_variations; version?: string; }) => Returns_${item.name};`
    );

    idEntries.push(`"${item.name}"`);

    for (const variation of item.variations) {
      entries.push(`'/${item.name}/${variation}'`);
    }
  }

  // Generate the complete file content
  const fileContent = `
${imports.join("\n")}

${variationTypes.join("\n")}

export type types = {
${typeEntries.join("\n")}
};

export const items = [
  ${idEntries.join(",\n  ")},
] as const;

export const entries = [
  ${entries.join(",\n  ")},
] as const;
`;

  return fileContent;
}
